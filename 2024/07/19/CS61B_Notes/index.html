

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/head.jpg">
  <link rel="icon" href="/img/head.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="思源南路世一劈">
  <meta name="keywords" content="">
  
    <meta name="description" content="这篇笔记包括了 CS61B 排序之前的部分的笔记，不包括项目和 lab 为什么不包括排序部分呢，主要是因为之前学习过相关的内容，在看 61B 的时候便省略掉了，至于项目部分，我会将 gitlet 单独写为一篇笔记发布 By：思源南路世一劈 Week 16 月 29 日CS61B，启动！ 虽然之前在学校简单把 Week 1 的内容看完了并且把 proj0 写完了，但是现在已经基本忘记了，所以现在开始">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61B 笔记">
<meta property="og:url" content="http://example.com/2024/07/19/CS61B_Notes/index.html">
<meta property="og:site_name" content="Home">
<meta property="og:description" content="这篇笔记包括了 CS61B 排序之前的部分的笔记，不包括项目和 lab 为什么不包括排序部分呢，主要是因为之前学习过相关的内容，在看 61B 的时候便省略掉了，至于项目部分，我会将 gitlet 单独写为一篇笔记发布 By：思源南路世一劈 Week 16 月 29 日CS61B，启动！ 虽然之前在学校简单把 Week 1 的内容看完了并且把 proj0 写完了，但是现在已经基本忘记了，所以现在开始">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/assets/compilation_figure.svg">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_double_sentinel_size_2.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap2/fig25/insert_experiment.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/assets/subclass.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/assets/list_subclasses.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/assets/comparable_interface.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/assets/comparator.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap9/intro1_resized.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap9/intro2_resized.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap9/intro3_resized.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap9/9.2.1.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap9/9.3.1.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap9/9.4.1.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/chap9/9.4.2.png">
<meta property="og:image" content="https://joshhug.gitbooks.io/hug61b/content/assets/heap-13.2.1.png">
<meta property="og:image" content="c:\Users\21045\AppData\Roaming\Typora\typora-user-images\image-20240721230413781.png">
<meta property="article:published_time" content="2024-07-19T12:52:34.000Z">
<meta property="article:modified_time" content="2024-08-19T14:14:44.232Z">
<meta property="article:author" content="思源南路世一劈">
<meta property="article:tag" content="Data Structure">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://joshhug.gitbooks.io/hug61b/content/assets/compilation_figure.svg">
  
  
  
  <title>CS61B 笔记 - Home</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>41P&#39;s Corner</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/ayaka.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CS61B 笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-19 20:52" pubdate>
          2024年7月19日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          119 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CS61B 笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>这篇笔记包括了 CS61B 排序之前的部分的笔记，不包括项目和 lab</p>
<p>为什么不包括排序部分呢，主要是因为之前学习过相关的内容，在看 61B 的时候便省略掉了，至于项目部分，我会将 gitlet 单独写为一篇笔记发布</p>
<p>By：思源南路世一劈</p>
<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h2 id="6-月-29-日"><a href="#6-月-29-日" class="headerlink" title="6 月 29 日"></a>6 月 29 日</h2><p>CS61B，启动！</p>
<p>虽然之前在学校简单把 Week 1 的内容看完了并且把 proj0 写完了，但是现在已经基本忘记了，所以现在开始重新开始我的数据结构学习之旅！</p>
<h3 id="Java-简介"><a href="#Java-简介" class="headerlink" title="Java 简介"></a>Java 简介</h3><p>Java 是<strong>面向对象编程</strong>的语言，在 CS61B 中将担任我们主要使用的语言</p>
<h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上为 Java 中 Hello world 程序的代码，由该代码块我们可以理解 Java 程序的基本结构：</p>
<ul>
<li>Java 程序文件均由一个个类构成，体现其<strong>面向对象编程</strong>的特点</li>
<li>类名与文件名相同</li>
<li>main 函数为类的主函数，其中<code>String args[]</code>表示 main 函数的参数(记住就行)</li>
<li><code>System.out.println()</code>是 Java 的输出函数，类比 C++中的<code>cout</code>和<code>printf</code></li>
</ul>
<h4 id="运行-Java-程序"><a href="#运行-Java-程序" class="headerlink" title="运行 Java 程序"></a>运行 Java 程序</h4><p>执行 Java 程序最常见的方法是通过两个程序的序列运行它。第一个是 Java 编译器，或 <code>javac</code> 。第二个是 Java 解释器，或 <code>java</code></p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/compilation_figure.svg" srcset="/img/loading.gif" lazyload alt="compilationflow"></p>
<p>例如，要运行 <code>HelloWorld.java</code> ，我们会在终端中输入命令 <code>javac HelloWorld.java</code> ，然后输入命令 <code>java HelloWorld</code> 。结果会类似于这样：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ <span class="hljs-keyword">javac </span>HelloWorld.<span class="hljs-keyword">java</span><br><span class="hljs-keyword"></span>$ <span class="hljs-keyword">java </span>HelloWorld<br>Hello World!<br></code></pre></td></tr></table></figure>

<h4 id="其他基本语法"><a href="#其他基本语法" class="headerlink" title="其他基本语法"></a>其他基本语法</h4><p>循环，条件等语法同 C++相同，不再赘述，即<code>for</code>循环，<code>while</code>循环和，<code>if-else</code>条件语句</p>
<h3 id="Java-中类和函数"><a href="#Java-中类和函数" class="headerlink" title="Java 中类和函数"></a>Java 中类和函数</h3><h4 id="Java-中的函数"><a href="#Java-中的函数" class="headerlink" title="Java 中的函数"></a>Java 中的函数</h4><p>由于所有的 Java 代码都是类的一部分，我们必须定义函数，使其属于某个类。属于类的函数通常被称为“方法”。</p>
<ul>
<li>返回类型可类比 C++：<code>void</code>,<code>int</code>,<code>double</code>等</li>
<li><code>public</code>前缀表示这个函数是该类的公共方法，相对应的是 <code>private</code></li>
</ul>
<p>一个基础 Demo 如下，效果为返回较大的数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LargerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">larger</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(larger(<span class="hljs-number">8</span>, <span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Java-中的类"><a href="#Java-中的类" class="headerlink" title="Java 中的类"></a>Java 中的类</h4><p>总体来说，Java 中类的基本语法同 C++中大体相似，例如使用 <strong>.</strong> 来调用类的函数以及变量，又例如<code>this</code>指针等，这里列出比较重要的几点：</p>
<ul>
<li><code>new</code>关键字：用来实例化类变量，注意，虽然 Java 中没有严格意义上的指针，但<code>new</code>的逻辑事实上也可以类比 C++中的类的指针申请新的动态变量，例如如下代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> weightInPounds;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<br>        weightInPounds = w;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">20</span>);<br>        Dog B;<br>        B = A;<br>        B.weightpounds = <span class="hljs-number">30</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码执行后，A 与 B 事实上是同一条狗，它们的体重都是 30</p>
<ul>
<li><code>static</code>关键字：</li>
</ul>
<p>Java 允许我们定义两种类型的方法：</p>
<ol>
<li>类方法，又称静态方法</li>
<li>实例方法，又称非静态方法</li>
</ol>
<p>实例方法是只能由类的特定实例执行的操作。静态方法是由类本身执行的操作。在不同情况下，两者都很有用。作为静态方法的一个示例， <code>Math</code> 类提供了一个 <code>sqrt</code> 方法。因为它是静态的，我们可以按照以下方式调用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">x = Math.sqrt(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p>如果 <code>sqrt</code> 是一个实例方法，我们将会有下面这种尴尬的语法。幸运的是 <code>sqrt</code> 是一个静态方法，所以我们在真实的程序中不必这样做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Math</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Math</span>();<br>x = m.sqrt(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p>有时候，拥有一个同时包含实例方法和静态方法的类是有意义的。例如，假设想要比较两只狗的能力。做到这一点的一种方法是添加一个用于比较狗的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Dog <span class="hljs-title function_">maxDog</span><span class="hljs-params">(Dog d1, Dog d2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (d1.weightInPounds &gt; d2.weightInPounds) &#123;<br>        <span class="hljs-keyword">return</span> d1;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方法可以被调用，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">15</span>);<br><span class="hljs-type">Dog</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">100</span>);<br>Dog.maxDog(d, d2);<br></code></pre></td></tr></table></figure>

<p>观察到我们已经使用类名调用，因为这个方法是一个静态方法</p>
<p>同理，使用<code>static</code>关键字定义的变量即为静态变量，可由类名直接调用</p>
<hr>
<h1 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h1><h2 id="7-月-1-日"><a href="#7-月-1-日" class="headerlink" title="7 月 1 日"></a>7 月 1 日</h2><h3 id="JUnits"><a href="#JUnits" class="headerlink" title="JUnits"></a>JUnits</h3><p>写的代码是需要测试的，从头开始，我们可以写自己的测试程序：</p>
<p>假设我们有一个给字符串数组排序的类 Sort，我们现在需要给它编写测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSort</span> &#123;<br>    <span class="hljs-comment">/** Tests the sort method of the Sort class. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSort</span><span class="hljs-params">()</span> &#123;<br>        String[] input = &#123;<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>&#125;;<br>        String[] expected = &#123;<span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;;<br>        Sort.sort(input);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.length; i += <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!input[i].equals(expected[i])) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Mismatch in position &quot;</span> + i + <span class="hljs-string">&quot;, expected: &quot;</span> + expected + <span class="hljs-string">&quot;, but got: &quot;</span> + input[i] + <span class="hljs-string">&quot;.&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        testSort();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很显然，这是最原始的方法，吃力不讨好</p>
<p><code>org.junit</code> 库提供了许多有用的方法和功能，可以简化测试编写。例如，我们可以用以下方法替换上面的简单的临时测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSort</span><span class="hljs-params">()</span> &#123;<br>    String[] input = &#123;<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>&#125;;<br>    String[] expected = &#123;<span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;;<br>    Sort.sort(input);<br>    org.junit.Assert.assertArrayEquals(expected, input);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>进一步简化，可以得到更舒适的写代码体验：</p>
<p>我们将讨论两个主要的增强功能</p>
<p>第一个增强是使用所谓的“测试注释”。为此，我们：</p>
<ul>
<li>在每个方法之前加上 <code>@org.junit.Test</code> （不要分号）。</li>
<li>将每个测试方法更改为非静态。</li>
<li>从 <code>TestSort</code> 类中删除我们的 <code>main</code> 方法。</li>
</ul>
<p>一旦我们完成了这三件事，如果我们在 JUnit 中使用 Run-&gt;Run 命令重新运行我们的代码，所有的测试都会执行，而无需手动调用。这种基于注解的方法有几个优点：</p>
<ul>
<li>无需手动调用测试。</li>
<li>所有测试都会运行，不仅仅是我们指定的那些。</li>
<li>如果一个测试失败，其他测试仍然会继续运行。</li>
<li>提供了运行了多少次测试以及有多少次测试通过的计数。</li>
<li>测试失败时的错误消息看起来好多了。</li>
<li>如果所有测试都通过，我们会收到一条好消息，并且会出现一个绿色的条形图，而不是什么输出都没有。</li>
</ul>
<p>第二个增强功能将允许我们对一些非常冗长的方法名称以及注解名称使用更短的名称。具体来说，我们将使用所谓的“导入语句”。</p>
<p>我们首先在文件顶部添加导入语句 <code>import org.junit.Test;</code> 。这样做之后，我们可以将所有 <code>@org.junit.Test</code> 的实例替换为简单的 <code>@Test</code> 。</p>
<p>然后我们添加第二个导入语句 <code>import static org.junit.Assert.*</code> 。这样做之后，我们可以在任何地方省略我们之前有 <code>org.junit.Assert.</code> 的地方。例如，我们可以用简单地 <code>assertEquals(expected2, actual2);</code> 替换 <code>org.junit.Assert.assertEquals(expected2, actual2);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSort</span><span class="hljs-params">()</span> &#123;<br>    String[] input = &#123;<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>&#125;;<br>    String[] expected = &#123;<span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;i&quot;</span>&#125;;<br>    Sort.sort(input);<br>    assertArrayEquals(expected, input);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上所示</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>从 0 开始创建自己的列表！</p>
<h4 id="IntLists"><a href="#IntLists" class="headerlink" title="IntLists"></a>IntLists</h4><p>初始设想是利用链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> first;<br>    <span class="hljs-keyword">public</span> IntList rest;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntList</span><span class="hljs-params">(<span class="hljs-type">int</span> f, IntList r)</span> &#123;<br>        first = f;<br>        rest = r;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="SLList"><a href="#SLList" class="headerlink" title="SLList"></a>SLList</h4><p>显然，在这上面直接添加函数方法会很裸奔，我们选择将核心提出，并创建新的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> item;<br>    <span class="hljs-keyword">public</span> IntNode next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntNode</span><span class="hljs-params">(<span class="hljs-type">int</span> i, IntNode n)</span> &#123;<br>        item = i;<br>        next = n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SLList</span> &#123;<br>    <span class="hljs-keyword">public</span> IntNode first;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SLList</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Adds an item to the front of the list. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, first);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的 SLList 即为新的列表数据结构，同样的，可以添加得到一系列实用的方法，如<code>addfirst</code>,<code>addlast</code>,<code>getfirst</code>,<code>getlast</code>,但是这时得到的数据结构仍然有不方便以及危险的地方：</p>
<ul>
<li>first 结点依然裸奔!</li>
<li>空列表无法舒适地 addlast</li>
</ul>
<p>为此，我们继续优化，首先将结点类型改为 private，其次设置哨兵结点(sentinel)，即添加一个始终位于最前端的结点，确保数据结构不是空的，这样便以一种类似<strong>数分中“一致连续”的手法</strong>处理了上述问题，实现了一致性。这也是编写代码的重要原则之一</p>
<p>代码就略了，我懒</p>
<p>实际上不会改变 A 中数据的值，因为这里的 x 也是 A 中数据按照值传递到 x 的</p>
<hr>
<h1 id="Week-3"><a href="#Week-3" class="headerlink" title="Week 3"></a>Week 3</h1><h2 id="7-月-3-日"><a href="#7-月-3-日" class="headerlink" title="7 月 3 日"></a>7 月 3 日</h2><h3 id="Lists-1"><a href="#Lists-1" class="headerlink" title="Lists"></a>Lists</h3><p>(续 Week 2 中的 SLLists 部分)</p>
<p>在 SLList 中，我们优化了裸数据结构带来的不便，同时添加了哨兵结点来维持不变性，但是，这样的 Lists 仍然具有一些可以优化的地方：</p>
<ul>
<li><code>addLast</code>时，总会遍历整个链表，如果我的列表长达一百万项，这将浪费时间</li>
<li>单向遍历，不利于快速访问元素&#x2F;删除元素，尤其是靠后的元素，每次访问都需要经历不必要的遍历</li>
</ul>
<p>由此，我们引出双向链表——<strong>Double Linked List</strong>，即<code>DLList</code></p>
<h4 id="DLList"><a href="#DLList" class="headerlink" title="DLList"></a>DLList</h4><p>添加前向指针(这个说法不严谨但是我先这么写)，使得列表变成可以双向访问的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntNode</span> &#123;<br>    <span class="hljs-keyword">public</span> IntNode prev;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> item;<br>    <span class="hljs-keyword">public</span> IntNode next;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同时为末端结点同样设置一个哨兵结点，由此得到的数据结构会类似下面的拓扑图：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_double_sentinel_size_2.png" srcset="/img/loading.gif" lazyload alt="dllist_double_sentinel_size_2.png"></p>
<p>也可以首尾共用一个哨兵结点，实现环形结构：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" srcset="/img/loading.gif" lazyload alt="dllist_circular_sentinel_size_2.png"></p>
<p>最后，加入“模板”(在 C++里是模板)，使得我们的列表“通用化”——</p>
<p>一个可以容纳任何类型的通用 <code>DLList</code> 看起来如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLList</span>&lt;BleepBlorp&gt; &#123;<br>    <span class="hljs-keyword">private</span> IntNode sentinel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntNode</span> &#123;<br>        <span class="hljs-keyword">public</span> IntNode prev;<br>        <span class="hljs-keyword">public</span> BleepBlorp item;<br>        <span class="hljs-keyword">public</span> IntNode next;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们已经定义了一个 <code>DLList</code> 类的通用版本，我们还必须使用特殊的语法来实例化这个类。为此，在声明时，我们将所需的类型放在尖括号内，并在实例化时使用空的尖括号。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">DLList&lt;String&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLList</span>&lt;&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br>d2.addLast(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>由于泛型仅适用于引用类型，我们无法将原始类型如 <code>int</code> 或 <code>double</code> 放入尖括号中，例如 <code>&lt;int&gt;</code> 。相反，我们使用原始类型的引用版本，在 <code>int</code> 情况下是 <code>Integer</code> ，例如。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">DLList&lt;Integer&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLList</span>&lt;&gt;(<span class="hljs-number">5</span>);<br>d1.insertFront(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<p>有关使用通用类型的更多细微差别，我们将把它们推迟到本书的后面章节。现在，请使用以下经验法则：</p>
<ul>
<li>在实现数据结构的.java 文件中，在类名之后的文件顶部只需指定一次泛型类型名称。</li>
<li>在其他 .java 文件中，使用您的数据结构时，在声明时指定特定的期望类型，并在实例化时使用空的尖括号运算符。</li>
<li>如果您需要实例化一个泛型到原始类型，请使用它们的原始等效项 <code>Integer</code> ， <code>Double</code> ， <code>Character</code> ， <code>Boolean</code> ， <code>Long</code> ， <code>Short</code> ， <code>Byte</code> 或 <code>Float</code> 。</li>
</ul>
<p>细节：在实例化时，您也可以在尖括号内声明类型，尽管这并非必需，只要您也在同一行上声明变量。换句话说，下面的代码行是完全有效的，即使右侧的 <code>Integer</code> 是多余的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DLList&lt;Integer&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLList</span>&lt;Integer&gt;(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<h4 id="AList"><a href="#AList" class="headerlink" title="AList"></a>AList</h4><p>最后，我们将使用另一种不同的手法来实现 List——数组！这样可以极大优化查找元素带来的时间损失，首先下面是数组相关的基础知识：</p>
<h5 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h5><p>实例化数组的三种方法：</p>
<ul>
<li><code>x = new int[3];</code></li>
<li><code>y = new int[]&#123;1, 2, 3, 4, 5&#125;;</code></li>
<li><code>int[] z = &#123;9, 10, 11, 12, 13&#125;;</code></li>
</ul>
<p>包含数组基本操作的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] z = <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span>[] x, y;<br><br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>y = x;<br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">99</span>&#125;;<br>y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>z = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">xL</span> <span class="hljs-operator">=</span> x.length;<br><br>String[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">6</span>];<br>s[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;ketchup&quot;</span>;<br>s[x[<span class="hljs-number">3</span>] - x[<span class="hljs-number">1</span>]] = <span class="hljs-string">&quot;muffins&quot;</span>;<br><br><span class="hljs-type">int</span>[] b = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br>System.arraycopy(b, <span class="hljs-number">0</span>, x, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>最后一行展示了一种将信息从一个数组复制到另一个数组的方法。 <code>System.arraycopy</code> 接受五个参数：</p>
<ul>
<li>The array to use as a source</li>
<li>Where to start in the source array</li>
<li>The array to use as a destination</li>
<li>Where to start in the destination array</li>
<li>How many items to copy</li>
</ul>
<p><code>System.arraycopy(b, 0,x, 3, 2)</code> 相当于 Python 中的 <code>x[3:5] = b[0:2]</code></p>
<h5 id="AList-使用数组实现列表"><a href="#AList-使用数组实现列表" class="headerlink" title="AList(使用数组实现列表)"></a>AList(使用数组实现列表)</h5><p>这一节有趣的主要是如何在数组满员时“扩展数组”，一开始我们使用的是逐 1 相加，但是测试结果表明这样的效率甚至远远不如 <code>SLList</code> !</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig25/insert_experiment.png" srcset="/img/loading.gif" lazyload alt="fig25/insert_experiment.png">将加的数额改成 100？1000？不，这样做的时间消耗始终是平方级别的，我们使用乘法来扩展数组，实现效率的极大提升！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBack</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == items.length) &#123;<br>           resize(size + RFACTOR);<br>    &#125;<br>    items[size] = x;<br>    size += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBack</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == items.length) &#123;<br>           resize(size * RFACTOR);<br>    &#125;<br>    items[size] = x;<br>    size += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后记得将 AList 数组列表模板化，以适应不同的使用需求</p>
<p>注意这里的语法有细微区别，这是 Java 中数组的特性所决定的：</p>
<p>Java 不允许我们创建一个泛型对象数组，因为泛型的实现方式存在一个模糊的问题。也就是说，我们不能做类似以下的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glorp[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Glorp</span>[<span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure>

<p>相反，我们必须使用下面的抽象语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Glorp[] items = (Glorp []) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">8</span>];<br></code></pre></td></tr></table></figure>

<p>这将产生一个编译警告，暂时不用管。我们将在后面更详细地讨论</p>
<h3 id="Inheritance-and-Implements"><a href="#Inheritance-and-Implements" class="headerlink" title="Inheritance and Implements"></a>Inheritance and Implements</h3><p>继承与实现！继续学习 Java 的编程特性，同时更加深入地学习列表等数据结构！这一节的内容主要包括：继承，转换，扩展，高阶函数，多态与 Java 库和包，我们书接上文，从我们熟悉的 SLList 和 DLList，AList 讲起······</p>
<p>假设我们有一个计算最长单词的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">longest</span><span class="hljs-params">(SLList&lt;String&gt; list)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i += <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">longestString</span> <span class="hljs-operator">=</span> list.get(maxDex);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">thisString</span> <span class="hljs-operator">=</span> list.get(i);<br>        <span class="hljs-keyword">if</span> (thisString.length() &gt; longestString.length()) &#123;<br>            maxDex = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list.get(maxDex);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 AList 类型的列表怎么办？我们当然可以使用函数重载(Overload，类比 C++)，写两个一模一样的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">longest</span><span class="hljs-params">(AList&lt;String&gt; list)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i += <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">longestString</span> <span class="hljs-operator">=</span> list.get(maxDex);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">thisString</span> <span class="hljs-operator">=</span> list.get(i);<br>        <span class="hljs-keyword">if</span> (thisString.length() &gt; longestString.length()) &#123;<br>            maxDex = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list.get(maxDex);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>真是颇费笔墨！呃啊！代码维护性降低了！以后有新的列表类型加入时还得再写一遍！</p>
<p>类比 C++中子类与父类的操作，我们直接掏出<strong>Inheritance</strong>，御敌于国门之外——</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/subclass.png" srcset="/img/loading.gif" lazyload alt="subclass"></p>
<h4 id="Interface-Inheritance"><a href="#Interface-Inheritance" class="headerlink" title="Interface Inheritance"></a>Interface Inheritance</h4><h5 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h5><p>首先登场的是接口继承(虽然这个翻译怪怪的)！选用 <code>List61B</code> 作为二者的超类，注意这里的语法规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List61B</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(Item x)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> add <span class="hljs-title function_">Last</span><span class="hljs-params">(Item y)</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Item x, <span class="hljs-type">int</span> position)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，我们在两个子类中<strong>分别实现上述方法</strong>即可，注意声明类的时候的特殊语法！</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">public class <span class="hljs-type">AList</span>&lt;<span class="hljs-type">Item</span>&gt; implements <span class="hljs-type">List61B</span>&lt;<span class="hljs-type">Item</span>&gt;<span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure>

<p><code>implements List61B&lt;Item&gt;</code> 本质上是一个承诺。AList 表示<strong>“我承诺我将拥有并定义 List61B 接口中指定的所有属性和行为”</strong>，二者的关系实际上是**”is-a”<strong>，不是</strong>“has-a”**</p>
<h5 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h5><p>在子类中实现所需的功能时，在方法签名的顶部包含 <code>@Override</code> 标签是有用的（实际上在 61B 中是必需的）。在这里，我们只为一个方法做了这样的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(Item x)</span> &#123;<br>    insert(x, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>即使不包括此标签，也可以覆盖该方法。因此，在技术上不必包括它。但是，包括标签可以作为程序员的保障，向编译器发出警告，表明您打算覆盖此方法。假设要覆盖 <code>addLast</code> 方法。如果您入错误并意外地写成 <code>addLsat</code> 会怎么样？如果不包括@Override 标签，那么可能无法发现错误。而如果您包括@Override，编译器将会停止并提示在程序运行之前修复错误。</p>
<h4 id="Implement-Inheritance"><a href="#Implement-Inheritance" class="headerlink" title="Implement Inheritance"></a>Implement Inheritance</h4><h5 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h5><p>我们也可以在超类中即对某些方法进行实现，对于不需要重写该方法的子类，调用该方法即直接调用超类的实现，而也有的子类需要重写该方法，再各做修改即可。为了做到这一点，必须在方法签名中包含 <code>default</code> 关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size(); i += <span class="hljs-number">1</span>) &#123;<br>        System.out.print(get(i) + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>List61B 类的所有子类都可以使用这个方法！</p>
<p>然而，对于 SLList， <code>get</code> 方法需要在每次调用时遍历整个列表。最好在遍历时直接打印！我们希望 SLList 以不同于其接口规定的方式打印。为了做到这一点，我们需要覆盖它。在 SLList 中，我们实现了这个方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> sentinel.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        System.out.print(p.item + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，每当我们在 SLList 上调用 print()时，它将调用这个方法，而不是 List61B 中的方法。</p>
<h5 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h5><p>Java 怎么知道使用哪个方法？这就需要提到我们的静态类型与动态类型——</p>
<p>假设有以下代码(这是合法的)：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">List61B&lt;<span class="hljs-type">String</span>&gt; lst = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SLList</span>&lt;<span class="hljs-type">String</span>&gt;();<br></code></pre></td></tr></table></figure>

<p>In the above declaration and instantiation, lst is of type “List61B”. This is called the <strong>“static type”</strong></p>
<p>However, the objects themselves have types as well. the object that lst points to is of type SLList. Although this object is intrinsically an SLList (since it was declared as such), it is also a List61B, because of the <strong>“is-a”</strong> relationship we explored earlier. But, because the object itself was instantiated using the SLList constructor, We call this its <strong>“dynamic type”</strong>.</p>
<p>Aside: the name “dynamic type” is actually quite semantic in its origin! Should lst be reassigned to point to an object of another type, say a AList object, lst’s dynamic type would <strong>now be AList and not SLList</strong>! It’s dynamic because it changes based on the type of the object it’s currently referring to.</p>
<p>当 Java 运行一个被覆盖的方法时，它会在其动态类型中搜索适当的方法签名并运行它。</p>
<h4 id="Interface-Inheritance-VS-Implement-Inheritance"><a href="#Interface-Inheritance-VS-Implement-Inheritance" class="headerlink" title="Interface Inheritance VS Implement Inheritance"></a>Interface Inheritance VS Implement Inheritance</h4><p>二者的区别与优劣如何？我这里直接摘录教材原文——</p>
<ul>
<li>Interface inheritance (what): Simply tells what the subclasses should be able to do.<ul>
<li>EX) all lists should be able to print themselves, how they do it is up to them.</li>
</ul>
</li>
<li>Implementation inheritance (how): Tells the subclasses how they should behave.<ul>
<li>EX) Lists should print themselves exactly this way: by getting each element in order and then printing them.</li>
</ul>
</li>
</ul>
<p>When you are creating these hierarchies, remember that the relationship between a subclass and a superclass should be an “is-a” relationship. AKA Cat should only implement Animal Cat <strong>is an</strong> Animal. You should not be defining them using a “has-a” relationship. Cat <strong>has-a</strong> Claw, but Cat definitely should not be implementing Claw.</p>
<p>Finally, Implementation inheritance may sound nice and all but there are some drawbacks:</p>
<ul>
<li>We are fallible humans, and we can’t keep track of everything, so it’s possible that you overrode a method but forgot you did.</li>
<li>It may be hard to resolve conflicts in case two interfaces give conflicting default methods.</li>
<li>It encourages overly complex code</li>
</ul>
<hr>
<h1 id="Week-4"><a href="#Week-4" class="headerlink" title="Week 4"></a>Week 4</h1><p>By：思源南路世一劈</p>
<h2 id="7-月-4-日"><a href="#7-月-4-日" class="headerlink" title="7 月 4 日"></a>7 月 4 日</h2><p>第四周……嗯，其实是第四天(雾)，这几天进度拉的有点快，需要放慢节奏了</p>
<p>目前计划是先肝到 Week 5，然后补掉前面的所有 discs，同时开始写 proj1，预计 7&#x2F;7 前收掉</p>
<p>这样 CS61B 的内容大概就肝完 40%了，接下来迈入数据结构领域的同时迎接这个超大的挑战：Gitlet！(即 proj2)</p>
<p>预计在 7&#x2F;14 前(即去成都之前)把 proj2 的进度推到 60%，7&#x2F;20 前彻底收掉</p>
<p>这样剩余的部分基本就是一些编程哲学类的视频，预计 7&#x2F;25 前彻底收尾</p>
<p>备注：proj3 应该是不写的，除非我能找到队友，收掉 61B 后着手预习电路理论，ICS 与离散数学(当然不可能都学，学一些是一些吧)！</p>
<p>至于交大教材版本的 ds，我的打算是跟着课本敲熟悉一遍代码，然后考虑刷点力扣熟悉 STL，保证开学之前拥有跟得上软工大二的码力(虽然我没选 SEP)</p>
<h3 id="Inheritance-and-Implements-1"><a href="#Inheritance-and-Implements-1" class="headerlink" title="Inheritance and Implements"></a>Inheritance and Implements</h3><p>(续 Week 3 部分)</p>
<h4 id="Extends"><a href="#Extends" class="headerlink" title="Extends"></a>Extends</h4><p>之前我们讲到类可以继承 <code>interface</code> ，这里的继承方式又分为实现继承与接口继承(而前者是有风险的)，那么类想要继承类该怎么办呢？</p>
<p>使用 <code>extend</code> 关键字，即可实现对类的继承，这里的继承可类比 C++里的 public 继承，但是没有 C++里面类型那么多，一个典型的例子如下(接续 Week 3 中提到的两种继承自 List61B 的 Lists)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RotatingSLList</span>&lt;Item&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SLList</span>&lt;Item&gt;<br></code></pre></td></tr></table></figure>

<p>关系图如下所示：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/list_subclasses.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>通过使用 <code>extends</code> 关键字，<strong>子类</strong>继承父类的<strong>所有成员</strong>。”成员”包括：</p>
<ul>
<li>All instance and static variables</li>
<li>All methods</li>
<li>All nested classes</li>
</ul>
<p><strong>构造函数不会被继承</strong>，私有成员不能被子类直接访问</p>
<h5 id="Object-class"><a href="#Object-class" class="headerlink" title="Object class"></a>Object class</h5><p>Java 中的所有类都是 Object 的后代，或也可以说成”是 Object 类”(is-a)</p>
<p>Object 类提供了很多基本的方法，例如<code>toString()</code> ， <code>equals()</code> 等，可以选择重写也可以选择不重写</p>
<h5 id="Type-Checking-and-Casting"><a href="#Type-Checking-and-Casting" class="headerlink" title="Type Checking and Casting"></a>Type Checking and Casting</h5><p>Java 在编译时进行类型检查，此处检查时的依据是<strong>静态类型</strong>而不是动态类型，因此在代码中有时候会有必要添加显式的”强制类型转换”来<strong>告诉编译器</strong>这个地方该讲什么什么东西<strong>视作</strong>什么什么东西，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Poodle</span> <span class="hljs-variable">largerPoodle</span> <span class="hljs-operator">=</span> (Poodle) maxDog(frank, frankJr); <span class="hljs-comment">// compiles! Right hand side has compile-time type Poodle after casting</span><br></code></pre></td></tr></table></figure>

<p>但是类型转换也有风险，正如货币天然是金银，但金银天然不是货币，可能会引发类型转换错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Poodle</span> <span class="hljs-variable">frank</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Poodle</span>(<span class="hljs-string">&quot;Frank&quot;</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">Malamute</span> <span class="hljs-variable">frankSr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Malamute</span>(<span class="hljs-string">&quot;Frank Sr.&quot;</span>, <span class="hljs-number">100</span>);<br><br><span class="hljs-type">Poodle</span> <span class="hljs-variable">largerPoodle</span> <span class="hljs-operator">=</span> (Poodle) maxDog(frank, frankSr); <span class="hljs-comment">// runtime exception!</span><br></code></pre></td></tr></table></figure>

<p>在这种情况下，我们比较一只贵宾犬和一只马拉穆特犬。如果没有进行强制转换，编译器通常不会允许调用 <code>maxDog</code> 进行编译，因为右侧的编译时类型将是 Dog，而不是 Poodle。然而，强制转换允许这段代码通过，当 <code>maxDog</code> 在运行时返回马拉穆特犬时，我们尝试将马拉穆特犬强制转换为贵宾犬时，会遇到一个运行时异常 - 一个 <code>ClassCastException</code></p>
<h4 id="Inheritance-Cheatsheet"><a href="#Inheritance-Cheatsheet" class="headerlink" title="Inheritance Cheatsheet"></a>Inheritance Cheatsheet</h4><p><code>VengefulSLList extends SLList</code> 表示 VengefulSLList “是” SLList，并继承了 SLList 的所有成员：</p>
<ul>
<li>Variables, methods nested classes</li>
<li>Not constructors Subclass constructors must invoke superclass constructor first. The <code>super</code> keyword can be used to invoke overridden superclass methods and constructors.</li>
</ul>
<p>覆盖方法的调用遵循两个简单规则：</p>
<ul>
<li>Compiler plays it safe and only allows us to do things according to the static type.</li>
<li>For overridden methods (<em>not overloaded methods</em>), the actual method invoked is based on the dynamic type of the invoking expression</li>
<li>Can use casting to overrule compiler type checking.</li>
</ul>
<h4 id="HoF-and-Subtype-Polymorphism"><a href="#HoF-and-Subtype-Polymorphism" class="headerlink" title="HoF and Subtype Polymorphism"></a>HoF and Subtype Polymorphism</h4><p>这一节讲的主要是高阶函数以及子类的多态性</p>
<p>Java 中没有 Python 中那般方便的函数参数，也没有 JavaScript 里的回调函数，亦没有 C++里的函数指针</p>
<p>那么在 Java 中，该如何实现高阶函数的操作呢？答案是使用类继承的模式来书写，即使这样十分冗长。这是因为 Java 是纯面向对象编程的语言。</p>
<p>在了解到 HoF 的书写模式后，进一步深入，我们便得到了类似 C++里面类似”运算符重载”的操作，这在下一节，即可迭代对象与迭代器里又有着新的应用</p>
<h5 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h5><p>编写一个接口，定义任何接受整数并返回整数的函数 - 一个 <code>IntUnaryFunction</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IntUnaryFunction</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们可以编写一个类， <code>implements IntUnaryFunction</code> 以表示一个具体的函数。让我们创建一个函数，该函数接受一个整数并返回该整数的 10 倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TenX</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IntUnaryFunction</span> &#123;<br>    <span class="hljs-comment">/* Returns ten times the argument. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> * x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，我们已经用 Java 编写了 <code>tenX</code> 函数的 Python 等价函数。现在让我们写 <code>do_twice</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_twice</span><span class="hljs-params">(IntUnaryFunction f, <span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> f.apply(f.apply(x));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Java 中，对 <code>print(do_twice(tenX, 2))</code> 的调用将如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(do_twice(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TenX</span>(), <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure>

<p>事实上，这里的接口扮演的角色即可以类比为 C++里的函数指针，而在实际调用时候的 <code>new Tenx()</code> 参数也可以换成其他的 subclass，以便于实现不同函数效果，为此我们只需要为不同的 subclass 写出不同的 apply 方法即可</p>
<h5 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h5><p>多态性，指的是对象可以具有多种形式或类型。在面向对象编程中，多态性涉及对象如何被视为其自身类的实例，其超类的实例，其超类的超类的实例等</p>
<p>考虑一个静态类型为 Deque 的变量 <code>deque</code> 。在执行时，调用 <code>deque.addFirst()</code> 将取决于 <code>addFirst</code> 被调用时 <code>deque</code> 的运行时类型或动态类型。正如我们在上一章中看到的，Java 使用动态方法选择来决定调用哪个方法</p>
<p>从狗狗们的故事引入————</p>
<p>还是以一直陪伴我们的 Dog 类为例，现在我想写一个函数 maxDog，给出两条狗里更大的那一条：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">maxDog</span><span class="hljs-params">(Dog d1,Dog d2)</span>&#123;<br>	<span class="hljs-keyword">if</span> (d1 &gt; d2)<br>        <span class="hljs-keyword">return</span> d1;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> d2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>暗藏玄坤！大于号是可以用的吗？这里很显然会出问题，我们需要对 Dog 类的比较方法进行一个定义</p>
<p>考虑从现有接口 Comparable 继承，这是来自 Java 的内置接口，用来实现比较功能：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/comparable_interface.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Dog&gt; &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Dog uddaDog)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.size - uddaDog.size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的<strong>OurComparable</strong>是我们自己实现的可比较对象的接口，但是显然没有官方的完善</p>
<p>由此便实现了类似 C++中对“&lt;,&gt;”符号的<strong>运算符重载</strong>，只不过是 Java 特色重载</p>
<p>那么，如果我不想按照 size 的大小比较狗狗，而是按照狗狗名字的首字母顺序来给狗狗比较大小，又该怎么办呢？</p>
<p>也就是说，我需要<strong>实现多种不同的比大小方法</strong>时该怎么办？引出我们的第二位兄弟：<code>Comparator</code>。Java 这样做的方式是通过使用 <code>Comparator</code> 。由于比较器是一个对象，我们将使用 <code>Comparator</code> 的方式是在 Dog 内编写一个实现 <code>Comparator</code> 接口的嵌套类，该接口的内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这表明 <code>Comparator</code> 接口要求任何实现类实现 <code>compare</code> 方法。 <code>compare</code> 的规则就像 <code>compareTo</code> ：</p>
<ul>
<li>Return negative number if o1 &lt; o2.</li>
<li>Return 0 if o1 equals o2.</li>
<li>Return positive number if o1 &gt; o2.</li>
</ul>
<p>实现的完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Dog&gt; &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Dog uddaDog)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.size - uddaDog.size;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NameComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Dog&gt; &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Dog a, Dog b)</span> &#123;<br>            <span class="hljs-keyword">return</span> a.name.compareTo(b.name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparator&lt;Dog&gt; <span class="hljs-title function_">getNameComparator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NameComparator</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Note that we’ve declared NameComparator to be a static class. A minor difference, but we do so because we do not need to instantiate a Dog to get a NameComparator. Let’s see how this Comparator works in action.</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/comparator.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>也是让鼠鼠大开眼界！</p>
<h3 id="Exceptions，Iterators，Iterables，Object-Methods"><a href="#Exceptions，Iterators，Iterables，Object-Methods" class="headerlink" title="Exceptions，Iterators，Iterables，Object Methods"></a>Exceptions，Iterators，Iterables，Object Methods</h3><p>进入下一部分，这一部分主要是一些 Java 语法知识的补充，包括异常、迭代、对象方法，了解完毕这些之后，CS61B 的第一部分(即 Java 的学习)也就宣告结束了(得益于自己 CPP 的底子，不然这些东西学起来不可能这么快······)</p>
<h4 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h4><p>异常会导致正常的控制流停止。实际上，我们可以选择抛出自己的异常。在 Python 中，您可能已经看到过这种情况，使用 <code>raise</code> 关键字。在 Java 中，异常是对象，我们使用以下格式抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionObject</span>(parameter1, ...)<br></code></pre></td></tr></table></figure>

<p>一个典型例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* Associates the specified value with the specified key in this map.</span><br><span class="hljs-comment">   Throws an IllegalArgumentException if the key is null. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;can&#x27;t add null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (contains(x)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    items[size] = x;<br>    size += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么这么做？以下是课本原文，我做如下摘抄：</p>
<p>We get an Exception either way - why is this better?</p>
<ol>
<li>We have control of our code: we consciously decide at what point to stop the flow of our program</li>
<li>More useful Exception type and helpful error message for those using our code</li>
</ol>
<p>However, it would be better if the program doesn’t crash at all. There are different things we could do in this case. Here are some below:</p>
<p><strong>Approach 1</strong>: Don’t add <code>null</code> to the array if it is passed into <code>add</code></p>
<p><strong>Approach 2</strong>: Change the <code>contains</code> method to account for the case if <code>items[i] == null</code>.</p>
<p>Whatever you decide, it is important that users know what to expect. That is why documentation (such as comments about your methods) is very important.</p>
<h4 id="Iterators-and-Iterables"><a href="#Iterators-and-Iterables" class="headerlink" title="Iterators and Iterables"></a>Iterators and Iterables</h4><p>迭代器与可迭代对象。这部分内容实际上就是 python 中迭代器的概念加上上文提到的用 Java 实现比较器的手段</p>
<p>相关的接口代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    T <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在此基础上我们实现了可迭代版本的 Arraysets，完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySet</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] items;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// the next item to be added will be at position size</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArraySet</span><span class="hljs-params">()</span> &#123;<br>        items = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns true if this map contains a mapping for the specified key.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(T x)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i += <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (items[i].equals(x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Associates the specified value with the specified key in this map.</span><br><span class="hljs-comment">       Throws an IllegalArgumentException if the key is null. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;can&#x27;t add null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (contains(x)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        items[size] = x;<br>        size += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns the number of key-value mappings in this map. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/** returns an iterator (a.k.a. seer) into ME */</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySetIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySetIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> wizPos;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArraySetIterator</span><span class="hljs-params">()</span> &#123;<br>            wizPos = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> wizPos &lt; size;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">returnItem</span> <span class="hljs-operator">=</span> items[wizPos];<br>            wizPos += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> returnItem;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArraySet&lt;Integer&gt; aset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;&gt;();<br>        aset.add(<span class="hljs-number">5</span>);<br>        aset.add(<span class="hljs-number">23</span>);<br>        aset.add(<span class="hljs-number">42</span>);<br><br>        <span class="hljs-comment">//iteration</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : aset) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Object-Methods"><a href="#Object-Methods" class="headerlink" title="Object Methods"></a>Object Methods</h4><p>如上文所述，Java 中所有的类都是 Object 类的子类，也可以说 Object 是最顶端的 superclass，继承的方法如下：</p>
<ul>
<li><code>String toString()</code></li>
<li><code>boolean equals(Object obj)</code></li>
<li><code>Class &lt;?&gt; getClass()</code></li>
<li><code>int hashCode()</code></li>
<li><code>protected Objectclone()</code></li>
<li><code>protected void finalize()</code></li>
<li><code>void notify()</code></li>
<li><code>void notifyAll()</code></li>
<li><code>void wait()</code></li>
<li><code>void wait(long timeout)</code></li>
<li><code>void wait(long timeout, int nanos)</code></li>
</ul>
<p>这里专注理解前两个即可</p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>相当于将某个对象字符串化的时候该怎么办？toString()解决的就是这个问题</p>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><p>注意，Java 中 <code>==</code> 在比较对象的时候实际上比较的是<strong>二者是否是同一个对象</strong>，即二者存储的地址是否相同。而这显然不符合特定情况下我们的要求，所以我们采取 <code>equals</code> 来<strong>重载我们的 <code>=</code></strong></p>
<hr>
<h2 id="7-月-6-日"><a href="#7-月-6-日" class="headerlink" title="7 月 6 日"></a>7 月 6 日</h2><p>牛魔，计划有变，估计要到 8 号才能写完 proj1 了</p>
<h2 id="7-月-7-日"><a href="#7-月-7-日" class="headerlink" title="7 月 7 日"></a>7 月 7 日</h2><p>补充一个继承的知识点：</p>
<ul>
<li>不能用 <code>super.super.something</code> 的方式来调用父类的父类，因为你只能有一个爹</li>
</ul>
<p>补充一个动态方法选择：</p>
<ul>
<li>编译时，在其静态类型中查看有无合适的签名，若有则<strong>锁定该签名</strong>，否则 Compile Error</li>
<li>运行时，在锁定签名的前提下，再在其动态类型查找有无更合适的方法，若无，则进一步查询其父类</li>
</ul>
<hr>
<h1 id="Week-5"><a href="#Week-5" class="headerlink" title="Week 5"></a>Week 5</h1><p>无事发生</p>
<hr>
<h1 id="Week-6"><a href="#Week-6" class="headerlink" title="Week 6"></a>Week 6</h1><h2 id="7-月-9-日"><a href="#7-月-9-日" class="headerlink" title="7 月 9 日"></a>7 月 9 日</h2><p>经过 7、8 二日的奋斗，终于写完了 Project 1，今天先续上前面的 Week 6</p>
<p>今天的内容主要是算法运行时间分析、不相交集合、ADTs(即抽象数据类型，主要介绍了 Map, Stack, BST 并基本实现了二叉搜索树 BST)</p>
<h3 id="Efficient-Programming"><a href="#Efficient-Programming" class="headerlink" title="Efficient Programming"></a>Efficient Programming</h3><p>名字很洋气，但是其实就是算法的运行时间分析。先扔一个符号的定义表格：</p>
<table>
<thead>
<tr>
<th align="center">Signals</th>
<th align="center">Informal Meaning</th>
<th align="center">Example Family</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Big Theta Θ(𝑓(𝑁))</td>
<td align="center">Order of growth is f(N)</td>
<td align="center">Θ(𝑁)</td>
</tr>
<tr>
<td align="center">Big O 𝑂(𝑓(𝑁))</td>
<td align="center">Order of growth is less than or equal to f(N)</td>
<td align="center">𝑂(𝑁)</td>
</tr>
<tr>
<td align="center">Big Omega Ω(𝑓(𝑁))</td>
<td align="center">Order of growth is greater than or equal to f(N)</td>
<td align="center">Ω(𝑁)</td>
</tr>
</tbody></table>
<p>然后我只需要列举一些常见的复杂度例子即可：</p>
<ul>
<li>N：单层遍历循环</li>
<li>N^2：双层遍历循环</li>
<li>log N：二分查找</li>
<li>N log N：归并排序</li>
</ul>
<h3 id="Disjoint-Sets"><a href="#Disjoint-Sets" class="headerlink" title="Disjoint Sets"></a>Disjoint Sets</h3><p>一个不相交集数据结构有固定数量的元素，每个元素最初都在自己的子集中。通过调用 <code>connect(x, y)</code> 来合并一些元素 <code>x</code> 和 <code>y</code> 的子集。</p>
<p>不相交集合主要有两种操作：</p>
<ul>
<li><code>connect(x, y)</code> ：连接 <code>x</code> 和 <code>y</code> 。又称为 <code>union</code></li>
<li><code>isConnected(x, y)</code> ：如果 <code>x</code> 和 <code>y</code> 连接（即属于同一集合），则返回 true</li>
</ul>
<p>一些操作示例如下图所示：</p>
<p>假设我们有四个元素，称为 A、B、C、D。首先，每个元素都在自己的集合中：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro1_resized.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在调用 <code>connect(A, B)</code> 后：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro2_resized.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">isConnected<span class="hljs-function"><span class="hljs-params">(A, B)</span> -&gt;</span> <span class="hljs-literal">true</span><br>isConnected<span class="hljs-function"><span class="hljs-params">(A, C)</span> -&gt;</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>在调用 <code>connect(A, D)</code> 后：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro3_resized.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>We find the set A is part of and merge it with the set D is part of, creating one big A, B, D set. C is left alone.<br>我们发现集合 A 是部分的，并将其与集合 D 是部分的合并，创建一个大的 A、B、D 集合。C 保持不变。<br><code>isConnected(A, D) -&gt; true</code><br><code>isConnected(A, C) -&gt; false</code></p>
<p>直观地，我们可能首先考虑将不相交集表示为一组集合，例如， <code>List&lt;Set&lt;Integer&gt;&gt;</code> 。但是这样对于一个很长的链表而言，查找与判断是否连接都将非常困难，并且在代码实现上也具有相当的难度，因此我们舍弃</p>
<p>接下来，我们从一步步优化这个数据结构入手，来探究不相交集合是怎样实现的：</p>
<h4 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h4><p>蛤！我们进行第一次优化，将不相交集合用数组的方式来实现</p>
<ul>
<li>The <strong>indices of the array</strong> represent the elements of our set.</li>
<li>The <strong>value at an index</strong> is the set number it belongs to.</li>
</ul>
<p>例如，我们将 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 表示为：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.2.1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这样一来，若想要连接某两个元素，只需要将其 id 修改为同一个数字即可</p>
<p>对于判断是否链接，也只需要检测这两个位置的 id 是否相同即可，时间复杂度是 Θ(1)！</p>
<p>但是构造函数与 <code>connect(x,y)</code> 需要的时间复杂度依然是 Θ(N)，我们继续······</p>
<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickFindDS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DisjointSets</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] id;<br><br>    <span class="hljs-comment">/* Θ(N) */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">QuickFindDS</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span>&#123;<br>        id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>            id[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* need to iterate through the array =&gt; Θ(N) */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> id[p];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">qid</span> <span class="hljs-operator">=</span> id[q];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; id.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (id[i] == pid)&#123;<br>                id[i] = qid;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* Θ(1) */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-keyword">return</span> (id[p] == id[q]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h4><p>我们继续优化，用近似树的结构来描述每一个集合：</p>
<p>不再使用 id，而是为每个项目分配其父项的索引。如果一个项目没有父项，那么它就是一个“根”，我们为其分配一个负值</p>
<p>这种方法使我们能够将我们的每个集合想象成一棵树。例如，我们将 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 表示为：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.3.1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>对于 QuickUnion，我们定义一个辅助函数 <code>find(int item)</code> ，它返回树 <code>item</code> 所在的根。例如，对于上面的集合， <code>find(4) == 0</code> ， <code>find(1) == 0</code> ， <code>find(5) == 3</code> 等。每个元素都有一个唯一的根。</p>
<p>这样一来，对于 <code>connect(x,y)</code> 函数，我们需要做的即是将 y 的根节点设置为 x 的根结点的子节点</p>
<p>对于 <code>isConnected(x,y)</code> 函数，我们需要做的即为找到二者的根节点并判断它们是否相等</p>
<p>注意到此时算法的性能将完全取决与 <code>find(X)</code> 的性能：当树很平缓时，二者性能都较为优良，当树狭长而高耸时，二者性能将退化为 N 的水平，因此这二者的时间复杂度都是 O(N)</p>
<p>是不是看起来像倒退了？但是注意这里的 O 符号表示的是小于等于，而我们只要控制好树的形状，便能尽量避免悲剧的发生，因此我们需要在 <code>connect(x,y)</code> 函数上继续下功夫</p>
<p>本小节的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickUnionDS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DisjointSets</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">QuickUnionDS</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">while</span> (parent[p] &gt;= <span class="hljs-number">0</span>) &#123;<br>            p = parent[p];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> find(p);<br>        <span class="hljs-type">int</span> j= find(q);<br>        parent[i] = j;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(p) == find(q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Weighted-Quick-Union-WQU"><a href="#Weighted-Quick-Union-WQU" class="headerlink" title="Weighted Quick Union (WQU)"></a>Weighted Quick Union (WQU)</h4><p>新规则：每当我们调用 <code>connect</code> 时，我们总是将较小树的根链接到较大树</p>
<p>遵循这个规则将使您的树的最大高度为 log𝑁log<em>N</em> ，其中 N 是我们不相交集中元素的数量</p>
<p>让我们通过一个例子来说明这个好处。考虑连接下面的两个集合 T1 和 T2：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.4.1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们有两种选项可以连接它们：</p>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.4.2.png" srcset="/img/loading.gif" lazyload alt="img"> 第一个选项是我们将 T1 链接到 T2。在第二个选项中，我们将 T2 链接到 T1。</p>
<p>第二个选项更可取，因为它只有 2 的高度，而不是 3。根据我们的新规则，我们也会选择第二个选项，因为 T2 比 T1 小（3 与 6 的大小相比）。</p>
<p>我们通过树中的项目数量来确定大小。因此，连接两棵树时，我们需要知道它们的大小（或权重）。我们可以将这些信息存储在树的根部，通过用 <code>-(size of tree)</code> 替换 <code>-1</code></p>
<p>还能继续优化吗？答案是可以，我们可以在按权重 connect 的同时进一步优化树的结构</p>
<h4 id="Weighted-Quick-Union-with-Path-Compression"><a href="#Weighted-Quick-Union-with-Path-Compression" class="headerlink" title="Weighted Quick Union with Path Compression"></a>Weighted Quick Union with Path Compression</h4><p>无论何时我们调用 <code>find(x)</code> ，我们都必须从 <code>x</code> 遍历到根。因此，在这个过程中，我们可以将所有访问的项目连接到它们的根，而不会增加额外的时间成本</p>
<p>将沿途所有项目连接到根部将有助于使我们的树在每次调用 <code>find</code> 时更短</p>
<p>注意到 <code>connect(x, y)</code> 和 <code>isConnected(x, y)</code> 总是调用 <code>find(x)</code> 和 <code>find(y)</code> 。因此，在调用足够多次 <code>connect</code> 或 <code>isConnected</code> 之后，基本上所有元素将直接指向它们的根。</p>
<p>通过推广， <code>connect</code> 和 <code>isConnected</code> 的平均运行时间在长期内几乎保持恒定！</p>
<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>总结如下：</p>
<p>N: number of elements in Disjoint Set</p>
<table>
<thead>
<tr>
<th>Implementation</th>
<th><code>isConnected</code></th>
<th><code>connect</code></th>
</tr>
</thead>
<tbody><tr>
<td>Quick Find</td>
<td>Θ(N)</td>
<td>Θ(1)</td>
</tr>
<tr>
<td>Quick Union</td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
<tr>
<td>Weighted Quick Union (WQU)</td>
<td>O(log N)</td>
<td>O(log N)</td>
</tr>
<tr>
<td>WQU with Path Compression</td>
<td>O(α(N))*</td>
<td>O(α(N))*</td>
</tr>
</tbody></table>
<h3 id="ADTs"><a href="#ADTs" class="headerlink" title="ADTs"></a>ADTs</h3><p>这一节主要介绍了一些抽象数据结构，抽象数据类型（ADT）仅由其操作定义，而不是由其实现定义。</p>
<p>Abstract data types (ADTs) are defined in terms of operations, not implementation.</p>
<p>Several useful ADTs:</p>
<ul>
<li>Disjoint Sets, Map, Set, List.</li>
<li>Java provides Map, Set, List interfaces, along with several implementations.</li>
</ul>
<p>同时，本章简单实现了一下二叉搜索树 BST。这里针对后者记录一下</p>
<h4 id="BST-二叉搜索树"><a href="#BST-二叉搜索树" class="headerlink" title="BST(二叉搜索树)"></a>BST(二叉搜索树)</h4><p>先给出树的一般定义：</p>
<p>Trees are composed of:</p>
<ul>
<li>nodes</li>
<li>edges that connect those nodes.<ul>
<li><strong>Constraint</strong>: there is only one path between any two nodes.</li>
</ul>
</li>
</ul>
<p>In some trees, we select a <strong>root</strong> node which is a node that has no parents.</p>
<p>A tree also has <strong>leaves</strong>, which are nodes with no children.</p>
<p>进一步我们有<strong>二叉树</strong>和<strong>二叉搜索树</strong>的定义：</p>
<ul>
<li><strong>Binary Trees</strong>: in addition to the above requirements, also hold the binary property constraint. That is, each node has either 0, 1, or 2 children.</li>
<li><strong>Binary Search Trees</strong>: in addition to all of the above requirements, also hold the property that For every node X in the tree:<ul>
<li>Every key in the left subtree is less than X’s key.</li>
<li>Every key in the right subtree is greater than X’s key. <strong>Remember this property!! We will reference it a lot throughout the duration of this module and 61B.</strong></li>
</ul>
</li>
</ul>
<p>Here is the BST class we will be using in this module:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>&lt;Key&gt; &#123;<br>    <span class="hljs-keyword">private</span> Key key;<br>    <span class="hljs-keyword">private</span> BST left;<br>    <span class="hljs-keyword">private</span> BST right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key, BST left, BST Right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以将 BST 视作是有序的二叉树，这在搜索的时候非常方便与迅速</p>
<h4 id="BST-的功能"><a href="#BST-的功能" class="headerlink" title="BST 的功能"></a>BST 的功能</h4><h5 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h5><p>类比二分查找，当我们想要查找 BST 中的数据的时候，思路是同样的：</p>
<ul>
<li>和当前结点的值比大小，若是则返回</li>
<li>若是小于待查值，则往右拐</li>
<li>若是大于待查值，则往左拐</li>
</ul>
<p>速度贼快！如果树很茂密，那么树的高度 H &#x3D; log N，即意味着查找用时也是 log N</p>
<h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h5><p>对于插入，总体思路和查找相似，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> BST <span class="hljs-title function_">insert</span><span class="hljs-params">(BST T, Key ik)</span> &#123;<br>  <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BST</span>(ik);<br>  <span class="hljs-keyword">if</span> (ik ≺ T.key)<br>    T.left = insert(T.left, ik);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ik ≻ T.key)<br>    T.right = insert(T.right, ik);<br>  <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h5><p>删除操作则需要分类讨论：</p>
<ul>
<li>被删除结点无子节点</li>
<li>被删除结点有一个子节点</li>
<li>被删除结点有两个子节点</li>
</ul>
<p>若无子节点，直接删除即可</p>
<p>若有一个子节点，子承父业</p>
<p>若有两个子节点，选贤者任之——即选择一个新节点替换之，那么怎么选择呢？<br>我们知道新节点必须:</p>
<ul>
<li>be &gt; than everything in left subtree.</li>
<li>be &lt; than everything right subtree.</li>
</ul>
<p>所以可以只需取左子树中最右边的节点或右子树中最左边的节点，然后把它放到待删除结点的位置即可！</p>
<hr>
<h1 id="Week-7"><a href="#Week-7" class="headerlink" title="Week 7"></a>Week 7</h1><h2 id="7-月-10-日"><a href="#7-月-10-日" class="headerlink" title="7 月 10 日"></a>7 月 10 日</h2><p>今天看完了 Week 7 的内容，主要内容包括两方面：一是对 BST 的进一步深化探究：B 树，红黑树；另一方面是对哈希(Hashing)的介绍，主要从如何实现高效的哈希表入手，并一步步优化更改，直到贴近实际的实现</p>
<h3 id="Balanced-Trees"><a href="#Balanced-Trees" class="headerlink" title="Balanced Trees"></a>Balanced Trees</h3><p>本章标题叫做”平衡树”，何谓平衡？我们知道，二叉搜索树虽然方便，但是其实际效能却取决于其结构：</p>
<p><strong>Worst case:</strong> Θ(𝑁)</p>
<p><strong>Best-case:</strong> Θ(log𝑁) (where 𝑁<em>N</em> is number of nodes in the tree)</p>
<p>于是引入 BST 性能的一些术语：</p>
<ul>
<li><strong>depth</strong>: the number of links between a node and the root.</li>
<li><strong>height</strong>: the lowest depth of a tree.</li>
<li><strong>average depth</strong>: average of the total depths in the tree.</li>
</ul>
<p><strong>树的高度</strong>决定了最坏情况的运行时间，因为在最坏情况下，我们要查找的节点位于树的底部。</p>
<p><strong>平均深度</strong>决定了平均情况下的运行时间。</p>
<h4 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h4><p>进入 B 树的领域！</p>
<p>B 树为什么叫这个名字视频中也没有提及，或许是因为 Balanced 的意义吧</p>
<p>牢 Josh 引入这个 B 树的想法还是相当疯狂的——</p>
<p>既然不想让高度太高，那我就不准插入子节点！但是这显然又是不行的，于是我们进一步修改，例如限制每个结点的数据数量，假设是 4，那么这时候插入结点的操作如下：</p>
<ol>
<li>We still always inserting into a leaf node, so take the node you want to insert and traverse down the tree with it, going left and right according to whether or not the node to be inserted is greater than or smaller than the items in each node.</li>
<li>After adding the node to the leaf node, if the new node has 4 nodes, then pop up the middle left node and re-arrange the children accordingly.</li>
<li>If this results in the parent node having 4 nodes, then pop up the middle left node again, rearranging the children accordingly.</li>
<li>Repeat this process until the parent node can accommodate or you get to the root.</li>
</ol>
<p>事实上，这时候树的建造过程就是”自下而上”的，这样自然也就保证了得到的树是自平衡的！进而保证了其 log N 的优异性能</p>
<p>这是一个很好用的 B 树可视化工具：</p>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization (usfca.edu)</a></p>
<h4 id="B-Trees-Invariants"><a href="#B-Trees-Invariants" class="headerlink" title="B-Trees Invariants"></a>B-Trees Invariants</h4><p>B-树具有以下有用的不变性：</p>
<ul>
<li>All leaves must be the same distance from the source.</li>
<li>A non-leaf node with 𝑘 items must have exactly 𝑘+1 children.</li>
</ul>
<p>In tandem, these invariants cause the tree to always be bushy.</p>
<p>发现没有，如果我们通过数据结构的教材自学，那么它一上来给我们的就是这样枯燥的东西，自然学懂起来就会复杂许多，而通过牢 Josh 这样生动丰富的讲解，才能让我们做到知其然亦知其所以然</p>
<h4 id="Rotating-Trees"><a href="#Rotating-Trees" class="headerlink" title="Rotating Trees"></a>Rotating Trees</h4><p>尽管 B 树性能优越，但实现起来却十分困难</p>
<p>为了让普通的 BST 也能实现平衡结构，我们引出旋转树的操作</p>
<p>旋转的正式定义是：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">rotateLeft(G): Let x be <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> child <span class="hljs-keyword">of</span> G. Make G <span class="hljs-keyword">the</span> <span class="hljs-built_in">new</span> left child <span class="hljs-keyword">of</span> x.<br>rotateRight(G): Let x be <span class="hljs-keyword">the</span> left child <span class="hljs-keyword">of</span> G. Make G <span class="hljs-keyword">the</span> <span class="hljs-built_in">new</span> <span class="hljs-literal">right</span> child <span class="hljs-keyword">of</span> x.<br></code></pre></td></tr></table></figure>

<p>理解上，可以将旋转的过程视作先将两个结点合并，再将原结点”发射”到另一侧的过程</p>
<p>相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(Node h)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.left;<br>    h.left = x.right;<br>    x.right = h;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateLeft</span><span class="hljs-params">(Node h)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.right;<br>    h.right = x.left;<br>    x.left = h;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red-Black Trees"></a>Red-Black Trees</h4><p>利用树旋转，我们最终来到红黑树——通过 BST 的结构来模拟 B 树，实现代码的简洁，同时保证效率与性能</p>
<p>Here is a summary of all the operations:</p>
<ul>
<li>When inserting: Use a red link.</li>
<li>If there is aright leaning “3-node”, we have a Left Leaning Violation<ul>
<li>Rotate left the appropriate node to fix.</li>
</ul>
</li>
<li>If there are two consecutive left links, we have an incorrect 4 Node Violation!<ul>
<li>Rotate right the appropriate node to fix.</li>
</ul>
</li>
<li>If there are any nodes with two red children, we have a temporary 4 Node.<ul>
<li>Color flip the node to emulate the split operation.</li>
</ul>
</li>
</ul>
<h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><p>Because a left-leaning red-black tree has a 1-1 correspondence with a 2-3 tree and will always remain within 2x the height of its 2-3 tree, the runtimes of the operations will take log𝑁log<em>N</em> time.</p>
<p>Here’s the abstracted code for insertion into a LLRB:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node h, Key key, Value val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, val, RED); &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> key.compareTo(h.key);<br>    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123; h.right = put(h.right, key, val); &#125;<br>    <span class="hljs-keyword">else</span>              &#123; h.val   = val;                    &#125;<br><br>    <span class="hljs-keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125;<br><br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>红黑树的删除过程较为繁琐，此处略去不谈</p>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><p>经过我们从 BST-BT-LLRB 的不断优化，查询的运行用时已经被我们做到了 log N 的境界，那么，还能进一步变强吗？(或者以空间换时间？)</p>
<p>基本思路是直接使用数组来替代上面那么复杂的数据结构——以空间换时间！直接用数组的 index 代表数据，用 true&#x2F;false 代表是否被存储——</p>
<ul>
<li>如何适用除数字以外的其他数据？——使用 ASCII！或者 Unicode！</li>
<li>不可避免的冲突？——内部使用 List 结构！</li>
<li>内存开销巨大？运行时不稳定？——使用限定大小且动态增长的数组！同时进一步改进我们的 Hashcode!</li>
</ul>
<p>这样便得到我们的哈希表——</p>
<ul>
<li>Inputs are converted by a hash function (<code>hashcode</code>) into an integer. Then, they’re converted to a valid index using the modulus operator. Then, they’re added at that index (dealing with collisions using LinkedLists).</li>
<li><code>contains</code> works in a similar fashion by figuring out the valid index, and looking in the corresponding LinkedList for the item.</li>
</ul>
<p>补充：哈希码具有三个必要属性，这意味着哈希码必须具备这些属性才能有效：</p>
<ol>
<li>It must be an Integer</li>
<li>If we run <code>.hashCode()</code> on an object twice, it should return the <strong>same</strong> number</li>
<li>Two objects that are considered <code>.equal()</code> must have the same hash code.</li>
</ol>
<p>这样，在哈希码分布均匀的情况下，查找的时间便被限制在了 O(1)的级别！</p>
<hr>
<h1 id="Week-8"><a href="#Week-8" class="headerlink" title="Week 8"></a>Week 8</h1><h2 id="7-月-11-日"><a href="#7-月-11-日" class="headerlink" title="7 月 11 日"></a>7 月 11 日</h2><p>Week 8 内容比较杂，先讲了一种全新的数据结构——优先级队列(PQ)，使用二叉堆的结构。随后简单给图的部分开了个头，介绍了图的定义和基本 API。然后介绍并讲解了深度优先遍历(DFS)和广度优先遍历(BFS)，以及它们的基本实现</p>
<h3 id="Heaps-and-Priority-Queues"><a href="#Heaps-and-Priority-Queues" class="headerlink" title="Heaps and Priority Queues"></a>Heaps and Priority Queues</h3><h4 id="PQ-Interfaces"><a href="#PQ-Interfaces" class="headerlink" title="PQ Interfaces"></a>PQ Interfaces</h4><p>和队列类似，优先级队列也可以添加&#x2F;删除元素，但和普通队列不同的是，优先级队列只能让我们访问其最小(或最大)的元素，这在一些需要排序的场合具有重大作用，其接口一般如下所示：(以最小优先级队列为例)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** (Min) Priority Queue: Allowing tracking and removal of</span><br><span class="hljs-comment">  * the smallest item in a priority queue. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MinPQ</span>&lt;Item&gt; &#123;<br>    <span class="hljs-comment">/** Adds the item to the priority queue. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Item x)</span>;<br>    <span class="hljs-comment">/** Returns the smallest item in the priority queue. */</span><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getSmallest</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/** Removes the smallest item from the priority queue. */</span><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">removeSmallest</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/** Returns the size of the priority queue. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如何实现？使用有序数组？BST？哈希表？各有优劣：</p>
<ul>
<li>Ordered Array<ul>
<li><code>add</code>: Θ(𝑁)</li>
<li><code>getSmallest</code>: Θ(1)</li>
<li><code>removeSmallest</code>: Θ(𝑁)</li>
</ul>
</li>
<li>Bushy BST<ul>
<li><code>add</code>: Θ(log𝑁)</li>
<li><code>getSmallest</code>: Θ(log𝑁)</li>
<li><code>removeSmallest</code>: Θ(log𝑁)</li>
</ul>
</li>
<li>HashTable<ul>
<li><code>add</code>: Θ(1)</li>
<li><code>getSmallest</code>: Θ(𝑁)</li>
<li><code>removeSmallest</code>: Θ(𝑁)</li>
</ul>
</li>
</ul>
<p>可以做的更好吗？由此引申出我们的二叉堆——一种特殊的树结构，用于实现我们的优先级队列</p>
<h4 id="Heaps"><a href="#Heaps" class="headerlink" title="Heaps"></a>Heaps</h4><p>堆的基本定义如下：</p>
<ul>
<li>首先是一颗<strong>完整的</strong>二叉树</li>
<li>每个结点的值<strong>小于等于</strong>其两个子节点的值(当然在求 max 的情况下反过来即可)</li>
<li>所有结点尽量<strong>左倾</strong></li>
</ul>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/heap-13.2.1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如上图所示：红色的即为不合规的堆<br>我们关心优先级队列的三种方法是 <code>add</code> ， <code>getSmallest</code> 和 <code>removeSmallest</code> 。</p>
<ul>
<li><code>add</code>: Add to the end of heap temporarily. Swim up the hierarchy to the proper place.<ul>
<li>Swimming involves swapping nodes if child &lt; parent</li>
</ul>
</li>
<li><code>getSmallest</code>: Return the root of the heap (This is guaranteed to be the minimum by our <em>min-heap</em> property</li>
<li><code>removeSmallest</code>: Swap the last item in the heap into the root. Sink down the hierarchy to the proper place.<ul>
<li>Sinking involves swapping nodes if parent &gt; child. Swap with the smallest child to preserve <em>min-heap</em> property</li>
</ul>
</li>
</ul>
<p>可以发现，这里调整堆的结构的一种很重要的思想就是”上浮”以及”下沉”！那么如何实现这种操作呢？</p>
<p>使用树？数组？这里就不卖关子了，事实上，一种极为巧妙的思路就是利用数组的 id 为每个堆的元素标号，这样一来，每个结点的编号与其父结点的编号便有了数学上的关系：</p>
<ul>
<li><code>leftChild(k)</code>&#x3D;𝑘∗2</li>
<li><code>rightChild(k)</code>&#x3D;𝑘∗2+1</li>
<li><code>parent(k)</code> &#x3D;𝑘&#x2F;2</li>
</ul>
<p>是不是很巧妙(doge)!</p>
<p>与其他的实现方式对比：</p>
<table>
<thead>
<tr>
<th align="center">Methods</th>
<th align="center">Ordered Array</th>
<th align="center">Bushy BST</th>
<th align="center">Hash Table</th>
<th align="center">Heap</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>add</code></td>
<td align="center">Θ(𝑁)</td>
<td align="center">Θ(log𝑁)</td>
<td align="center">Θ(1)Θ(1)</td>
<td align="center">Θ(log𝑁)</td>
</tr>
<tr>
<td align="center"><code>getSmallest</code></td>
<td align="center">Θ(1)</td>
<td align="center">Θ(log𝑁)</td>
<td align="center">Θ(𝑁)</td>
<td align="center">Θ(1)</td>
</tr>
<tr>
<td align="center"><code>removeSmallest</code></td>
<td align="center">Θ(𝑁)</td>
<td align="center">Θ(log𝑁)</td>
<td align="center">Θ(𝑁)</td>
<td align="center">Θ(log𝑁)</td>
</tr>
</tbody></table>
<h3 id="DS-Summary"><a href="#DS-Summary" class="headerlink" title="DS Summary"></a>DS Summary</h3><p>对已经学习过的数据结构进行一个总结：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Store Operation(s)</th>
<th>Primary Retrieval Operation</th>
<th>Retrieve By</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td><code>add(key)</code>, <code>insert(key, index)</code></td>
<td><code>get(index)</code></td>
<td>index</td>
</tr>
<tr>
<td>Map</td>
<td><code>put(key, value)</code></td>
<td><code>get(key)</code></td>
<td>key identity</td>
</tr>
<tr>
<td>Set</td>
<td><code>add(key)</code></td>
<td><code>containsKey(key)</code></td>
<td>key identity</td>
</tr>
<tr>
<td>PQ</td>
<td><code>add(key)</code></td>
<td><code>getSmallest()</code></td>
<td>key order (aka key size)</td>
</tr>
<tr>
<td>Disjoint Sets</td>
<td><code>connect(int1, int2)</code></td>
<td><code>isConnected(int1, int2)</code></td>
<td>two integer values</td>
</tr>
</tbody></table>
<p>下一集——图！</p>
<h3 id="Graph-DFS-BFS"><a href="#Graph-DFS-BFS" class="headerlink" title="Graph,DFS,BFS"></a>Graph,DFS,BFS</h3><p>其实这是两章的内容，但是我看牢 Josh 有点水课的嫌疑，所以放到一起了</p>
<p>先从树遍历讲起，然后引入图——</p>
<h4 id="Tree-Traversal"><a href="#Tree-Traversal" class="headerlink" title="Tree Traversal"></a>Tree Traversal</h4><p>回想一下，还在列表那一集的时候我们讲到了迭代的概念，对于列表来说这一切是如此自然——只需要一步步往后走便是了，那么对于树来说呢？</p>
<p>一共有四种遍历的方式：层序，先序，顺序，后序(翻译是这样的，感觉英文更好理解一些)</p>
<h5 id="Level-Order-Traversal"><a href="#Level-Order-Traversal" class="headerlink" title="Level Order Traversal"></a>Level Order Traversal</h5><p>顾名思义，一层一层遍历，从第 0 层(即根节点)开始，一步步向后推·······</p>
<p>得到的结果是： <code>D B F A C E G</code></p>
<h5 id="Pre-order-Traversal"><a href="#Pre-order-Traversal" class="headerlink" title="Pre-order Traversal"></a>Pre-order Traversal</h5><p>先序遍历，简记：我最大！然后左右</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">preOrder(BSTNode x) &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    print(x.key)<br>    preOrder(x.left)<br>    preOrder(x.right)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>得到的结果是：<code>D B A C F E G</code></p>
<h5 id="In-order-Traversal"><a href="#In-order-Traversal" class="headerlink" title="In-order Traversal"></a>In-order Traversal</h5><p>顺~序遍历，严格按照左中右的方式执行，这也是按顺序打印 BST 内容的方法</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">inOrder(BSTNode x) &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    inOrder(x.left)<br>    print(x.key)<br>    inOrder(x.right)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>得到的结果是：<code>A B C D E F G</code></p>
<h5 id="Post-order-Traserval"><a href="#Post-order-Traserval" class="headerlink" title="Post-order Traserval"></a>Post-order Traserval</h5><p>后序遍历——以大局为重！先集体后个人()</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">postOrder(BSTNode x) &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    postOrder(x.left)<br>    postOrder(x.right)<br>    print(x.key)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>得到的结果是：<code>A C B E G F D</code></p>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>开图！</p>
<p>什么是图？还记得树的定义吗？我们要求树里面任意两个结点之间有且仅有一条路径，在图里，没有这个限制</p>
<p>也就是说，所有的树都是图！下面给出图的定义：</p>
<p>A graph consists of:</p>
<ul>
<li>A set of nodes (or vertices)</li>
<li>A set of zero of more edges, each of which connects two nodes.</li>
</ul>
<p>图的分类很多，有向图&#x2F;无向图，简单图&#x2F;复杂图，非循环图&#x2F;循环图，加权图···等等，这里我们只研究简单图</p>
<h5 id="Basic-Problems"><a href="#Basic-Problems" class="headerlink" title="Basic Problems"></a>Basic Problems</h5><p>图研究的主要问题有：(英语太差，所以双语都放上来)</p>
<ul>
<li><strong>s-t Path</strong>: Is there a path between vertices s and t?<br>s-t 路径：顶点 s 和 t 之间是否有路径？</li>
<li><strong>Connectivity</strong>: Is the graph connected, i.e. is there a path between all vertices?<br>连通性：图是否连通，即所有顶点之间是否存在路径？</li>
<li><strong>Biconnectivity</strong>: Is there a vertex whose removal disconnects the graph?<br>双连通性：是否存在一个顶点，其移除会使图断开连接？</li>
<li><strong>Shortest s-t Path</strong>: What is the shortest path between vertices s and t?<br>最短 s-t 路径：顶点 s 和 t 之间的最短路径是什么？</li>
<li><strong>Cycle Detection</strong>: Does the graph contain any cycles?<br>循环检测：图中是否包含任何循环？</li>
<li><strong>Euler Tour</strong>: Is there a cycle that uses every edge exactly once?<br>欧拉循环: 是否存在一个使用每条边恰好一次的循环？</li>
<li><strong>Hamilton Tour</strong>: Is there a cycle that uses every vertex exactly once?<br>汉密尔顿循环：是否有一个循环，每个顶点恰好使用一次？</li>
<li><strong>Planarity</strong>: Can you draw the graph on paper with no crossing edges?<br>平面性：您能否在纸上绘制图形而不交叉边缘？</li>
<li><strong>Isomorphism</strong>: Are two graphs isomorphic (the same graph in disguise)?<br>同构：两个图同构（伪装成相同的图）？</li>
</ul>
<p>以第一个问题为例，我们可以引申出 DFS 和 BFS</p>
<h5 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth First Search"></a>Depth First Search</h5><p>深度优先搜索！不撞南墙不回头！</p>
<p>具体思路是：</p>
<ul>
<li>对于当前结点，先标记之</li>
<li>判断当前结点是否是目标结点，是则返回</li>
<li>对于该结点<strong>没有被标记</strong>的邻居结点，递归调用(否则会死循环)</li>
<li>若没有这样的邻居结点，则返回 False</li>
</ul>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">mark s  <span class="hljs-comment">// i.e., remember that you visited s already</span><br><span class="hljs-keyword">if</span> (s == t):<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">for</span> child in <span class="hljs-title function_">unmarked_neighbors</span><span class="hljs-params">(s)</span>: <span class="hljs-comment">// if a neighbor is marked, ignore!</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-title function_">isconnected</span><span class="hljs-params">(child, t)</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<h5 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth First Search"></a>Breadth First Search</h5><p>广度优先搜索！优先拿离自己进的人开 🔪！</p>
<p>具体思路：在 DFS 的基础之上，增加一个数组来跟踪哪些结点接下来将被调查！例如我们到达一个结点，在判断该结点的情况后，就标记该结点，再这个结点的非标记邻居拉近审查名单，随后审查名单便会动态增长或缩短，直到我们找到目的或者找遍整个图</p>
<p>BFS 的伪代码如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Initialize the fringe (a queue <span class="hljs-keyword">with</span> the starting vertex) <span class="hljs-keyword">and</span> mark that vertex.<br><span class="hljs-keyword">Repeat</span> <span class="hljs-keyword">until</span> fringe <span class="hljs-keyword">is</span> <span class="hljs-keyword">empty</span>:<br><span class="hljs-keyword">Remove</span> vertex v <span class="hljs-keyword">from</span> the fringe.<br><span class="hljs-keyword">For</span> <span class="hljs-keyword">each</span> unmarked neighbor n <span class="hljs-keyword">of</span> v:<br>Mark n.<br><span class="hljs-keyword">Add</span> n <span class="hljs-keyword">to</span> fringe.<br><span class="hljs-keyword">Set</span> edgeTo[n] = v.<br><span class="hljs-keyword">Set</span> distTo[n] = distTo[v] + <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure>

<p>A <em>fringe</em> is just a term we use for the data structure we are using to store the nodes on the frontier of our traversal’s discovery process (the next nodes it is waiting to look at). For BFS, we use a queue for our fringe.</p>
<p><code>edgeTo[...]</code> is a map that helps us track how we got to node <code>n</code>; we got to it by following the edge from <code>v</code> to to <code>n</code>.</p>
<p><code>distTo[...]</code> is a map that helps us track how far <code>n</code> is from the starting vertex. Assuming that each edge is worth a distance of <code>1</code>, then the distance to <code>n</code> is just one more than the distance to get to <code>v</code>. Why? We can use the way we know how to get to <code>v</code>, then pay one more to arrive at <code>n</code> via the edge that necessarily exists between <code>v</code> and <code>n</code> (it must exist since in the <code>for</code> loop header, <code>n</code> is defined as a neighbor of <code>v</code>).</p>
<h4 id="Representing-Graphs"><a href="#Representing-Graphs" class="headerlink" title="Representing Graphs"></a>Representing Graphs</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Graph</span><span class="hljs-params">(<span class="hljs-type">int</span> V)</span>:               <span class="hljs-comment">// Create empty graph with v vertices</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span>: <span class="hljs-comment">// add an edge v-w</span><br>  Iterable&lt;Integer&gt; <span class="hljs-title function_">adj</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span>:      <span class="hljs-comment">// vertices adjacent to v</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">V</span><span class="hljs-params">()</span>:                           <span class="hljs-comment">// number of vertices</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">E</span><span class="hljs-params">()</span>:                           <span class="hljs-comment">// number of edges</span><br>...<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Week-9"><a href="#Week-9" class="headerlink" title="Week 9"></a>Week 9</h1><h2 id="7-月-12-日-7-月-15-日"><a href="#7-月-12-日-7-月-15-日" class="headerlink" title="7 月 12 日-7 月 15 日"></a>7 月 12 日-7 月 15 日</h2><p>这几天摆了，主要原因是瞌睡太多(雾)，断断续续看了 Week 9 和 Week 10 的部分内容，这里记录一下 Week 9</p>
<p>Week 9 一方面是对图的内容进行了进一步的深入探讨，两方面：最短路径与最小生成树；另一方面则简单介绍了多维数据与 K-D-Tree(没记错的话应该是 ads 里面的内容)。但是对于后者我不打算记笔记，仅作为参考了解</p>
<h3 id="Shortest-Paths"><a href="#Shortest-Paths" class="headerlink" title="Shortest Paths"></a>Shortest Paths</h3><p>直接上干货吧，这没什么好引入的，主要内容重点是算法思想及其运行时，而非代码实现：</p>
<p>最短路径，即给定图中的任意两点，我们需要找到连接这两点之间的最短路径，这里的图有可能是加权图，即不同边的权重(a.k.a 长度)不一样。我们采用的方法主要有两种：**Dijkstra and A***，前者重在算无遗策，给出的答案绝对正确，而后者则是一种启发式算法，力求直捣黄龙，但是精度可能有影响！</p>
<h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>该算法的主要操作是：给你一个顶点，还你一颗最短路径树(即包含了该顶点到其他所有顶点的最短路径)</p>
<p>概括地说，该算法分三步走：</p>
<ul>
<li>创建一个 PQ，其内容即为各个顶点，对应的值时当前时刻每个顶点到源顶点的最短距离</li>
<li>将初始点的值设为 0，其他的设置为正无穷</li>
<li>当 PQ 非空时，弹出其顶点，并**放松(relax)**其所有边，直到 PQ 为空</li>
</ul>
<p>放松，即对当前顶点的所有边进行一个距离的检查，如果当前顶点的距离加上该边的权重小于该边另一个顶点的距离，则更新之。这个计算潜在距离、检查是否更好并可能更新的整个过程被称为放松(relax)。</p>
<p><strong>Important note: we never relax edges that point to already visited vertices.</strong> 所以不要忘记标记已经访问过的顶点，当某个顶点从 PQ 中弹出后，它就不会再次被访问</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java">def <span class="hljs-title function_">dijkstras</span><span class="hljs-params">(source)</span>:<br>    PQ.add(source, <span class="hljs-number">0</span>)<br>    For all other vertices, v, PQ.add(v, infinity)<br>    <span class="hljs-keyword">while</span> PQ is not empty:<br>        p = PQ.removeSmallest()<br>        relax(all edges from p)<br>def <span class="hljs-title function_">relax</span><span class="hljs-params">(edge p,q)</span>:<br>   <span class="hljs-keyword">if</span> q is <span class="hljs-title function_">visited</span> <span class="hljs-params">(i.e., q is not in PQ)</span>:<br>       <span class="hljs-keyword">return</span><br><br>   <span class="hljs-keyword">if</span> distTo[p] + weight(edge) &lt; distTo[q]:<br>       distTo[q] = distTo[p] + w<br>       edgeTo[q] = p<br>       PQ.changePriority(q, distTo[q])<br></code></pre></td></tr></table></figure>

<p>该算法的证明如下：(摘抄自课本)</p>
<p>Assume all edges are non-negative.</p>
<ul>
<li><p>At start, distTo[source] &#x3D; 0. This is optimal.</p>
</li>
<li><p>After relaxing all edges from source, let vertex 𝑣1be the vertex with the minimum weight (i.e., the one that’s closest to the source.)<strong>Claim: distTo[𝑣1] is optimal, i.e., whatever the value of distTo[𝑣1] is at this point is the shortest distance from 𝑠<em>s</em> to 𝑣1.</strong></p>
<p>Why?</p>
<ul>
<li>Let’s try to see why this <strong>MUST</strong> be the case.</li>
<li>Suppose that it isn’t the case. Then that means that there is some other path from 𝑠<em>s</em> to 𝑣1 which is shorter than the direct path (𝑠,𝑣1). Ok, so let’s consider this hypothetical cool shorter path… it would have to look like (𝑠,𝑣𝑎,𝑣𝑏,…,𝑣1). But… (𝑠,𝑣𝑎) is <strong>already</strong> bigger than (𝑠,𝑣1). (Note that this is true because 𝑣1 is the vertex that is closest to 𝑠 from above.) So how can such a path exist which is actually shorter? It can’t!</li>
</ul>
</li>
<li><p>Now, the next vertex to be popped will be 𝑣1. (Why? Note that it currently has the lowest priority in the PQ!)</p>
</li>
<li><p>So now, we can make this same argument for 𝑣1 and all the relaxation it does. (This is called “proof by induction”. It’s kind of like recursion for proofs.) And that’s it; we’re done.</p>
</li>
</ul>
<p>算法的局限性：边的权重必须非负！</p>
<h4 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h4><p>D 算法强调<strong>算无遗策</strong>，即我的探索路径类似一个同心圆，在抵达目标的同时事实上我也找到了同心圆里面的其他结点的所有最短路径，这似乎有点太城市化了？</p>
<p>如果能在 PQ 的排列中加上一点”方向性”就好了！即带有引导式的去引诱最短路径树的生长方向</p>
<p>事实上，我们只需要修改一下 D 算法：在 Dijkstra 算法中，我们使用 bestKnownDistToVbestKnownDistToV 作为算法中的 PQ 优先级。这一次，我们将使用 bestKnownDistToV+estimateFromVToGoalbestKnownDistToV+estimateFromVToGoal 作为我们的 PQ 优先级。</p>
<p>显然，如果这里的估计做的不好，显然算法的精度就会降低，但是如果估计做的好，那么该算法将拥有快于 D 算法的速度和更高的效率，显然更加美妙！例如在地图里寻找两个城市间的最短路径时，我们便可以采用两点间的<strong>直线距离</strong>来作为一个暂时的估计</p>
<p>这里是一个 A*算法演示： <a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/177bRUTdCa60fjExdr9eO04NHm0MRfPtCzvEup1iMccM/edit#slide=id.g771336078_0_180">demo</a></p>
<p>关于估计的要求，摘自教材：</p>
<p>The takeaway here is that heuristics need to be good. There are two definitions required for goodness.</p>
<ol>
<li>Admissibility. heuristic(v, target) ≤ trueDistance(v, target). (Think about the problem above. The true distance from the neighbor of 𝐶 to 𝐶 wasn’t infinity, it was much, much smaller. But our heuristic said it was ∞∞, so we broke this rule.)</li>
<li>Consistency. For each neighbor 𝑣 of 𝑤:<ul>
<li>heuristic(v, target) ≤ dist(v, w) + heuristic(w, target)</li>
<li>where dist(v, w) is the weight of the edge from v to w.<br>)</li>
</ul>
</li>
</ol>
<p>demo 详见：<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1_x9UraVHfARN3aVX--yMZ3TSx6oW21lzGcqzQxzcoHU/edit#slide=id.g50bd245468_0_1223">cs61b 2020 lec 25 shortest paths - Google 幻灯片</a></p>
<h3 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>最小生成树：指包含了图中所有结点的且总路径和最短的一棵树。当然这是我的理解，原文如下：</p>
<p>A minimum spanning tree (MST) is the lightest set of edges in a graph possible such that all the vertices are connected. Because it is a tree, it must be connected and acyclic. And it is called “spanning” since all vertices are included.</p>
<h4 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h4><p>我们可以将<strong>切割</strong>定义为将图的节点分配给两个非空集合的过程(即我们将每个节点分配给集合一或集合二)。</p>
<p>我们可以将横跨边定义为连接一个集合中的节点与另一个集合中的节点的边。</p>
<p>有了这两个定义，我们就可以理解<strong>切割属性</strong>；给定任何切割，最小权重的横跨边在最小生成树中。</p>
<h4 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h4><p>类似 Dijkstra 算法，只是将到源顶点的距离换成到当前树的距离，核心思想：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> Start <span class="hljs-built_in">from</span> some arbitrary <span class="hljs-built_in">start</span> node.<br><span class="hljs-number">2.</span> Repeatedly <span class="hljs-built_in">add</span> <span class="hljs-keyword">the</span> shortest edge that has <span class="hljs-literal">one</span> node inside <span class="hljs-keyword">the</span> MST under construction.<br><span class="hljs-number">3.</span> Repeat <span class="hljs-keyword">until</span> there are V<span class="hljs-number">-1</span> edges.<br></code></pre></td></tr></table></figure>

<p>一个算法演示：<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1GPizbySYMsUhnXSXKvbqV4UhPCvrt750MiqPPgU-eCY/edit#slide=id.g9a60b2f52_0_0">CS61B Prim’s Demo - Google 幻灯片</a></p>
<h4 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm"></a>Kruskal’s Algorithm</h4><p>实现起来较为简单，使用 PQ 对所有边排序然后直接霸王硬上弓：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> Sort all <span class="hljs-keyword">the</span> edges <span class="hljs-built_in">from</span> lightest <span class="hljs-built_in">to</span> heaviest.<br><span class="hljs-number">2.</span> Taking <span class="hljs-literal">one</span> edge <span class="hljs-keyword">at</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">time</span> (<span class="hljs-keyword">in</span> sorted order), <span class="hljs-built_in">add</span> <span class="hljs-keyword">it</span> <span class="hljs-built_in">to</span> our MST under construction <span class="hljs-keyword">if</span> doing so does <span class="hljs-keyword">not</span> introduce <span class="hljs-keyword">a</span> cycle.<br><span class="hljs-number">3.</span> Repeat <span class="hljs-keyword">until</span> there are V<span class="hljs-number">-1</span> edges.<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="Week-10"><a href="#Week-10" class="headerlink" title="Week 10"></a>Week 10</h1><p>啥也没有！这一周是 UCB 的春假！</p>
<hr>
<h1 id="Week-11"><a href="#Week-11" class="headerlink" title="Week 11"></a>Week 11</h1><h2 id="7-月-15-日"><a href="#7-月-15-日" class="headerlink" title="7 月 15 日"></a>7 月 15 日</h2><p>最后两部分需要记笔记的内容：Trie 和 拓扑排序，前者是补充的最后一种数据结构，后者是图论的一点拓展和收尾</p>
<h3 id="Tries"><a href="#Tries" class="headerlink" title="Tries"></a>Tries</h3><p>懒了，开抄！字典树(或者叫做检索树)是针对字符串(即由 ASCII 码构成)的检索数据结构</p>
<p>让我们首先考虑一下对我们当前的 HashMap 实现的潜在改进。</p>
<h4 id="特殊情况-1：字符键映射"><a href="#特殊情况-1：字符键映射" class="headerlink" title="特殊情况 1：字符键映射"></a>特殊情况 1：字符键映射</h4><p>如果我们知道我们的键只是 ASCII 字符，我们可以放弃我们的通用 HashMap，而是使用一个数组，其中数组中的每个索引对应于特定的 ASCII 字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataIndexedCharMap</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">private</span> V[] items;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DataIndexedCharMap</span><span class="hljs-params">(<span class="hljs-type">int</span> R)</span> &#123;<br>        items = (V[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[R];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">char</span> c, V val)</span> &#123;<br>        items[c] = val;<br>    &#125;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> items[c];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是一个可能的实现，用于接受字符键的地图。值 R 代表可能字符的数量（例如 ASCII 的 128）。我们不再需要存储可能会影响运行时的任何桶（以额外内存为代价）。我们知道我们的数据将均匀分布。</p>
<h4 id="特殊情况-2：字符串键映射"><a href="#特殊情况-2：字符串键映射" class="headerlink" title="特殊情况 2：字符串键映射"></a>特殊情况 2：字符串键映射</h4><p>假设我们知道我们的键总是字符串。我们可以使用一种称为 Trie 的特殊数据结构。这种数据结构将字符串的每个字母存储为树中的一个节点。它在获取单词、添加单词和一些特殊字符串操作方面具有出色的性能。</p>
<h4 id="Trie-Demo-Trie"><a href="#Trie-Demo-Trie" class="headerlink" title="Trie Demo Trie"></a>Trie Demo Trie</h4><p>假设我们想要存储单词”sam”、”sad”、”sap”、”same”、”a”和”awls”。我们希望创建一个数据结构，使我们能够将这些单词添加进去，并清楚地表明我们的集合包含这些单词，而不包含这些单词的任何后缀或前缀。</p>
<p>There are a few key ideas for Tries:</p>
<ul>
<li>Every node stores only one letter.</li>
<li>Nodes can be shared by multiple keys.</li>
</ul>
<p>Consider a Trie with the words “sam” and “sad” already in it:</p>
<p>When we add the word “sap”, we can make use of the fact that we already have the prefix “sa” in the Trie:</p>
<p>Adding “same” follows a similar procedure. We have the prefix “sam” in the Trie, so we can use it to our advantage:</p>
<p>When adding “a”, our first instinct may be to add an edge between the root and the existing “a” in our Trie:</p>
<p>However, this way would be a bit misleading because we do not know if the “a” is the start of the word “ame”. Instead, we create an entirely new node</p>
<p>这已经看起来很不错了！我们可以清楚地看到我们在 Trie 中添加的单词。然而，有一个问题。我们应该只在 Trie 中有单词”sam”、”sad”、”sap”、”same”、”a”和”awls”。根据我们当前的结构，我们无法确定哪些前缀应该被视为在 Trie 中，哪些不应该。例如，我们希望前缀”sam”在 Trie 中，但我们不希望”awl”或”aw”被视为在 Trie 中。</p>
<p>为了解决这个问题，我们将把每个字符串的最后一个字符涂成蓝色，以示该字符结尾的单词</p>
<p>现在我们完成了！要搜索，我们将从根遍历我们的 Trie，并在下降时与我们正在搜索的字符串的每个字符进行比较。因此，只有两种情况我们找不到一个字符串；要么最终节点是白色的，要么我们掉出了树。</p>
<p>Examples:</p>
<ul>
<li><code>contains(&quot;sam&quot;)</code>: true, blue node</li>
<li><code>contains(&quot;sa&quot;)</code>: false, white node</li>
<li><code>contains(&quot;a&quot;)</code>: true, blue node</li>
<li><code>contains(&quot;saq&quot;)</code>: false, fell off tree</li>
</ul>
<p>Demo：<a target="_blank" rel="noopener" href="http://www.cs.princeton.edu/courses/archive/spring15/cos226/demo/52DemoTrie.mov">here</a></p>
<p><strong>Advantages of Tries.</strong> Tries have very fast lookup times, as we only ever look at as many characters as they are in the data we’re trying to retrieve. However, their chief advantage is the ability to efficiently support various operations not supported by other map&#x2F;set implementations including:</p>
<ul>
<li>longestPrefixOf</li>
<li>prefixMatches</li>
<li>spell checking</li>
</ul>
<h3 id="Reductions-and-Decomposition"><a href="#Reductions-and-Decomposition" class="headerlink" title="Reductions and Decomposition"></a>Reductions and Decomposition</h3><h4 id="Topological-Sorts"><a href="#Topological-Sorts" class="headerlink" title="Topological Sorts"></a>Topological Sorts</h4><p>拓扑排序，是图的顶点的一种排序，使得对于每条有向边 u→v，u 在排序中位于 v 之前</p>
<p>为什么叫这个名字？这可以从拓扑学的角度来理解：拖动图中的各个结点，使得它们排成一行，满足所有箭头都朝右，即得到了一种拓扑排序的可能</p>
<p><img src="C:\Users\21045\AppData\Roaming\Typora\typora-user-images\image-20240721230413781.png" srcset="/img/loading.gif" lazyload alt="image-20240721230413781"></p>
<p>相关算法实现如下：</p>
<p>How can we find a topological sort? Take a moment to think of existing graph algorithms you already know could be helpful in solving this problem.</p>
<p>Topological Sort Algorithm:</p>
<ul>
<li>Perform a DFS traversal from every vertex in the graph, <strong>not</strong> clearing markings in between traversals.</li>
<li>Record DFS postorder along the way.</li>
<li>Topological ordering is the reverse of the postorder.</li>
</ul>
<p><strong>Why it works:</strong> Each vertex <strong><em>v</em></strong> gets added to the end of the postorder list only after considering <strong>all</strong> descendants of <strong><em>v</em></strong>. Thus, when any <strong><em>v</em></strong> is added to the postorder list, all its descendants are already on the list. Thus reversing this list gives a topological ordering.</p>
<p>Since we’re simply using DFS, the runtime of this is <strong>O(V+E)</strong> where <strong>V</strong> and <strong>E</strong> are the number of nodes and edges in the graph respectively.</p>
<h4 id="DAGs"><a href="#DAGs" class="headerlink" title="DAGs"></a>DAGs</h4><p>有向无环图，这是拓扑排序的适用范围，也是很多算法的受限制范围</p>
<h4 id="Shortest-Path-Algorithm-for-DAGs"><a href="#Shortest-Path-Algorithm-for-DAGs" class="headerlink" title="Shortest Path Algorithm for DAGs"></a>Shortest Path Algorithm for DAGs</h4><p>介绍了拓扑排序，那么它有什么用呢？</p>
<p>回忆之前学过的 Dijkstra 算法，当 DAGs 中存在负边权时，算法可能会遭遇失败！那么能否在 D 算法的大体框架之上做出一些修改，使得其能够规避掉负边权的影响？</p>
<p>先想想为什么负边权会导致算法失效——在负边权的作用下，有时候我们会”放松”某条边，但是放松后相应的某些顶点距离却并没有被更新，这是由于负边权在放松机制下产生了一种类似于”穿越”的效果。如果先将图进行拓扑排序，再按照排序后的顶点顺序进行 D 算法的思路，便可完美规避负边权的影响！</p>
<h4 id="Longest-Paths"><a href="#Longest-Paths" class="headerlink" title="Longest Paths"></a>Longest Paths</h4><p>在不能利用循环刷步数的前提下，如何求最长路径？(其实这个问题至今无解，即使是最佳的可行性算法也是指数级别的时间，根本无法应用)</p>
<p>考虑将问题范围缩小到 DAG，这便是我们能解决的范畴了。事实上，使用的方法很像小学以及初中的数学思考题：</p>
<ol>
<li>Form a new copy of the graph, called G’, with all edge weights negated (signs flipped).</li>
<li>Run DAG shortest paths on G’ yielding result X</li>
<li>Flip the signs of all values in X.distTo. X.edgeTo is already correct.</li>
</ol>
<h4 id="Reductions-and-Decomposition-1"><a href="#Reductions-and-Decomposition-1" class="headerlink" title="Reductions and Decomposition"></a>Reductions and Decomposition</h4><p>说了这大半天才扯到本章的标题，这到底指的是什么意思呢？——</p>
<p>用 SPT-DAG 的方法来解决 LPT-DAG 问题，便是一种 reduction 的策略。</p>
<p>This process is known as <strong>reduction</strong>. Since DAG-SPT can be used to solve DAG-LPT, we say that “DAG-LPT reduces to DAG-SPT.”</p>
<p>它的定义如下：</p>
<p><strong>if any subroutine for task Q can be used to solve P, we say P reduces to Q</strong></p>
<p>Perhaps a better term for what we’ve been accomplishing earlier in the course is <em>decomposition</em> - breaking a complex task into smaller parts. Using abstraction to make problem solving easier. This is the heart of computer science.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CS61B/" class="category-chain-item">CS61B</a>
  
  
    <span>></span>
    
  <a href="/categories/CS61B/Notes/" class="category-chain-item">Notes</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Data-Structure/" class="print-no-link">#Data Structure</a>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CS61B 笔记</div>
      <div>http://example.com/2024/07/19/CS61B_Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>思源南路世一劈</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/23/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E8%AE%B2%E5%BA%A7%E8%AE%B2%E4%B9%89/" title="数学分析讲座讲义">
                        <span class="hidden-mobile">数学分析讲座讲义</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
